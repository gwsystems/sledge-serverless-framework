#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include "memlogging.h"
#include "lock.h"

#define MAX_NODES 4096 // Maximum number of nodes in the pool

typedef uint64_t (*binary_tree_get_priority_fn_t)(void *data);
typedef uint64_t (*binary_tree_get_execution_cost_fn_t)(void *data, int thread_id);

// Define the colors for Red-Black Tree
typedef enum { RED, BLACK } Color;

// Definition of a binary search tree node
struct TreeNode {
    struct TreeNode *left;
    struct TreeNode *right;
    struct TreeNode *next;  // pointing to the next node, this is used for nodePool 
                            // to find next available node
    struct TreeNode *dup_next; // pointing to next duplicate key item
    struct TreeNode *parent;
    Color           color;
    uint64_t        left_subtree_sum;
    void            *data;  // sandbox 
};

// Definition of TreeNode memory pool
struct TreeNodePool {
    struct TreeNode* head;
};

struct binary_tree {
	struct TreeNode 	            *root;
	struct TreeNodePool                 nodePool;
	binary_tree_get_priority_fn_t       get_priority_fn;
	binary_tree_get_execution_cost_fn_t get_execution_cost_fn;
	lock_t                              lock;
	bool                                use_lock;
	int                                 id;
        int                                 queue_length;
};

// Initialize the node pool
void initNodePool(struct TreeNodePool *nodePool, int pool_size) {
    
    assert(nodePool != NULL);

    struct TreeNode *nodes = (struct TreeNode*)malloc(pool_size * sizeof(struct TreeNode));
    nodePool->head = nodes;  // Initialize head to the beginning of the node array
 
    for (int i = 0; i < MAX_NODES - 1; ++i) {
        nodes[i].next  = &nodes[i + 1];  // Set the next pointer of each node to the next node
        nodes[i].left  = NULL;
        nodes[i].right = NULL;
        nodes[i].dup_next = NULL;
	nodes[i].parent = NULL;
        nodes[i].color = RED;
        nodes[i].left_subtree_sum = 0;
        nodes[i].data  = NULL;
    }
    nodes[MAX_NODES - 1].next = NULL;
}

struct binary_tree * init_binary_tree(bool use_lock, binary_tree_get_priority_fn_t get_priority_fn, 
				      binary_tree_get_execution_cost_fn_t get_execution_cost_fn, int id, int queue_size) {
	
	assert(get_priority_fn != NULL);

	struct binary_tree *binary_tree = (struct binary_tree *)calloc(1, sizeof(struct binary_tree));
	initNodePool(&binary_tree->nodePool, queue_size);
	binary_tree->root = NULL;
	binary_tree->get_priority_fn = get_priority_fn;
	binary_tree->get_execution_cost_fn = get_execution_cost_fn;
	binary_tree->use_lock = use_lock;
	binary_tree->id = id;
        binary_tree->queue_length = 0;
	
	if (binary_tree->use_lock) lock_init(&binary_tree->lock);

	return binary_tree;
}

// Function to get the total number of non-deleted nodes in the binary tree
int getNonDeletedNodeCount(struct binary_tree *binary_tree) {
    assert(binary_tree != NULL);
    return binary_tree->queue_length;
}

// Get a new node from the pool
struct TreeNode* newNode(struct binary_tree *binary_tree, Color color, struct TreeNode* left,
                         struct TreeNode* right, struct TreeNode* parent, void *data) {
    
    assert(binary_tree != NULL);

    if (binary_tree->nodePool.head == NULL) {
        panic("Binary search tree queue %d is full\n", binary_tree->id);
        return NULL;
    } else {
        // Remove a node from the head of the memory pool
        struct TreeNode* new_node_t = binary_tree->nodePool.head;
        binary_tree->nodePool.head = new_node_t->next;
        new_node_t->next = NULL;  // Reset the next pointer of the new node
        new_node_t->data = data;
	new_node_t->left = left;
        new_node_t->right = right;
        new_node_t->parent = parent;
        new_node_t->color = color;
        new_node_t->dup_next = NULL;
        new_node_t->left_subtree_sum = 0;
        return new_node_t;
    }
}

void getAvailableCapacity(struct binary_tree *binary_tree) {
	
    assert(binary_tree != NULL);
        
    int size = 0;
    struct TreeNode* start = binary_tree->nodePool.head;
    while(start) {
        size++;
        start = start->next;
    }

    printf("available capacity of the queue is %d\n", size);
}

void print_in_order(struct TreeNode* node) {
    if (node != NULL) {
        // Recursively traverse the left subtree
        print_in_order(node->left);
        
        // Print the data in the current node
	if (node->data) {
            mem_log("%lu(%lu) ", ((struct sandbox *)node->data)->absolute_deadline, ((struct sandbox *)node->data)->estimated_cost);
	}
        //Print data in the dup_next list
        struct TreeNode* cur = node->dup_next;
        while(cur) {
           mem_log("%lu(%lu) ", ((struct sandbox *)cur->data)->absolute_deadline, ((struct sandbox *)cur->data)->estimated_cost);
           cur = cur->dup_next;
        }

        // Recursively traverse the right subtree
        print_in_order(node->right);
    }
}

// Function to print the items in the binary search tree in order
void print_tree_in_order(struct binary_tree* bst) {
    if (bst != NULL) {
        print_in_order(bst->root);
        mem_log("\n");
    }
}

//get the total execute time of a node.
uint64_t get_sum_exe_time_of_node(struct binary_tree *binary_tree, struct TreeNode* node, int thread_id){
    uint64_t total = 0;
    struct TreeNode* curNode = node;
    while (curNode!=NULL) {
        total += binary_tree->get_execution_cost_fn(curNode->data, thread_id);
        curNode = curNode->dup_next;
    }

    return total;
}

//get the total execute time of a node's subtree, including left and right subtree
uint64_t get_sum_exe_time_of_subtree(struct binary_tree *binary_tree, struct TreeNode* root, int thread_id) {
    if (root == NULL) {
        return 0;
    }

    return get_sum_exe_time_of_node(binary_tree, root, thread_id) + 
	   root->left_subtree_sum + get_sum_exe_time_of_subtree(binary_tree, root->right, thread_id);
}


// Return a node to the pool
void deleteNode(struct binary_tree *binary_tree, struct TreeNode* node) {

    assert(binary_tree != NULL);
    assert(node != NULL);

    // Insert the node back to the head of the memory pool
    node->left = NULL;
    node->right = NULL;
    node->parent = NULL;
    node->color = RED;
    node->data = NULL;
    node->left_subtree_sum = 0;
    node->dup_next = NULL;
    node->next = binary_tree->nodePool.head;
    binary_tree->nodePool.head = node;
}

int findHeight(struct TreeNode *root)
{
    int lefth, righth;
    if(root == NULL)
        return 0;
    lefth = findHeight(root->left);
    righth = findHeight(root->right);
    return (lefth > righth ? lefth : righth)+1;
}

// Update root if rotating.
void leftRotate(struct binary_tree *binary_tree, struct TreeNode *x, int thread_id) {
    struct TreeNode *y = x->right;
    x->right = y->left;
    if (y->left != NULL)
        y->left->parent = x;

    y->parent = x->parent;

    if (x->parent == NULL)
        binary_tree->root = y;
    else if (x == x->parent->left)
        x->parent->left = y;
    else
        x->parent->right = y;
    y->left = x;
    x->parent = y;
    y->left_subtree_sum += binary_tree->get_execution_cost_fn(x->data, thread_id) + x->left_subtree_sum;
}

// Update root if rotatiing
void rightRotate(struct binary_tree *binary_tree, struct TreeNode *x, int thread_id) {
    struct TreeNode *y = x->left;
    x->left = y->right;

    int new_sum_left = 0;
    if (y->right != NULL) {
        y->right->parent = x;
        new_sum_left = get_sum_exe_time_of_subtree(binary_tree, y->right, thread_id); //y->right->exe_time + y->right->sum_left;
    }

    x->left_subtree_sum = new_sum_left;
    y->parent = x->parent;
    if (x->parent == NULL)
        binary_tree->root = y;
    else if (x == x->parent->right)
        x->parent->right = y;
    else
        x->parent->left = y;
    y->right = x;
    x->parent = y;
}

void insertFixup(struct binary_tree *binary_tree, struct TreeNode *z, int thread_id) {
    while (z->parent != NULL && z->parent->color == RED) {
        if (z->parent == z->parent->parent->left) {
            struct TreeNode *y = z->parent->parent->right;
            if (y != NULL && y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->right) {
                    z = z->parent;
                    leftRotate(binary_tree, z, thread_id);
                }
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                rightRotate(binary_tree, z->parent->parent, thread_id);
            }
        } else {
            struct TreeNode *y = z->parent->parent->left;
            if (y != NULL && y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->left) {
                    z = z->parent;
                    rightRotate(binary_tree, z, thread_id);
                }
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                leftRotate(binary_tree, z->parent->parent, thread_id);
            }
        }
    }
    binary_tree->root->color = BLACK;
}

// Function to insert a value into a binary search tree. Tree root might be changed after inserting a new node
void insert(struct binary_tree *binary_tree, void *data, int thread_id) {
    assert(binary_tree != NULL);

    struct TreeNode *z = newNode(binary_tree, RED, NULL, NULL, NULL, data);
    binary_tree->queue_length++;
    struct TreeNode *y = NULL;
    struct TreeNode *x = binary_tree->root;
    while (x != NULL) {
        y = x;

        //if found a dup_next deadline, inserted the node
        //at the end of the linklist
        if (binary_tree->get_priority_fn(z->data) == binary_tree->get_priority_fn(x->data)) {
            //find the tail the link list;
            struct TreeNode* tail = x;
            while (tail->dup_next != NULL) {
                tail = tail->dup_next;
            }
            //append the new node at the end of the list;
            tail->dup_next = z;
            z->color = x->color;
            z->left_subtree_sum = x->left_subtree_sum;
            return;
        } else if (binary_tree->get_priority_fn(z->data) < binary_tree->get_priority_fn(x->data)) {
            x->left_subtree_sum += binary_tree->get_execution_cost_fn(data, thread_id);
            x = x->left;
        } else {
            x = x->right;
        }
    }

    z->parent = y;
    if (y == NULL) {
        binary_tree->root = z;
    } else if (binary_tree->get_priority_fn(z->data) < binary_tree->get_priority_fn(y->data)) {
        y->left = z;
    } else {
        y->right = z;
    }
	
    insertFixup(binary_tree, z, thread_id);
}

// Helper function to find the minimum value in a binary search tree
struct TreeNode* findMin(struct binary_tree *binary_tree) {

    assert(binary_tree != NULL);

    struct TreeNode *curNode = binary_tree->root;
    if (curNode == NULL) {
        return NULL;
    }

    while (curNode->left != NULL) {
        curNode = curNode->left; // Keep traversing to the left until the leftmost node is reached
    }
    return curNode;
}

// Helper function to find the maximum value in a binary search tree
struct TreeNode* findMax(struct binary_tree *binary_tree) {

    assert(binary_tree != NULL);

    struct TreeNode *curNode = binary_tree->root;
    if (curNode == NULL) {
        return NULL;
    }

    while (curNode->right != NULL) {
        curNode = curNode->right; // Keep traversing to the right until the rightmost node is reached
    }
    return curNode;
}

struct TreeNode* searchByKey(struct binary_tree *binary_tree, void *data) {
    struct TreeNode* current = binary_tree->root;
    
    while (current != NULL && binary_tree->get_priority_fn(current->data) != binary_tree->get_priority_fn(data)) {
        if (binary_tree->get_priority_fn(data) < binary_tree->get_priority_fn(current->data)) {
            current = current->left;
        } else {
            current = current->right;
        }
    }

    return current;
}

void transplant(struct binary_tree *binary_tree, struct TreeNode *u, struct TreeNode *v) {
    if (u->parent == NULL)
        binary_tree->root = v;
    else if (u == u->parent->left)
        u->parent->left = v;
    else
        u->parent->right = v;
    if (v != NULL)
        v->parent = u->parent;
}

struct TreeNode* minimum(struct TreeNode *node) {
    while (node->left != NULL) {
        node = node->left;
    }
    return node;
}

void deleteFixup(struct binary_tree *binary_tree, struct TreeNode *x, int thread_id) {
    while (x != binary_tree->root && (x == NULL || x->color == BLACK)) {

        if (x == NULL){
            break;
        }

        if ( x == x->parent->left) {
            struct TreeNode *w = x->parent->right;
            if (w->color == RED) {
                w->color = BLACK;
                x->parent->color = RED;
                leftRotate(binary_tree, x->parent, thread_id);
                w = x->parent->right;
            }
            if ((w->left == NULL || w->left->color == BLACK) && (w->right == NULL || w->right->color == BLACK)) {
                w->color = RED;
                x = x->parent;
            } else {
                if (w->right == NULL || w->right->color == BLACK) {
                    if (w->left != NULL) w->left->color = BLACK;
                    w->color = RED;
                    rightRotate(binary_tree, w, thread_id);
                    w = x->parent->right;
                }
                w->color = x->parent->color;
                x->parent->color = BLACK;
                if (w->right != NULL) w->right->color = BLACK;
                leftRotate(binary_tree, x->parent, thread_id);
                x = binary_tree->root;
            }
        } else {
            struct TreeNode *w = x->parent->left;
            if (w->color == RED) {
                w->color = BLACK;
                x->parent->color = RED;
                rightRotate(binary_tree, x->parent, thread_id);
                w = x->parent->left;
            }
            if ((w->right == NULL || w->right->color == BLACK) && (w->left == NULL || w->left->color == BLACK)) {
                w->color = RED;
                x = x->parent;
            } else {
		if (w->left == NULL || w->left->color == BLACK) {
                    if (w->right != NULL) w->right->color = BLACK;
                    w->color = RED;
                    leftRotate(binary_tree, w, thread_id);
                    w = x->parent->left;
                }
                w->color = x->parent->color;
                x->parent->color = BLACK;
                if (w->left != NULL) w->left->color = BLACK;
                rightRotate(binary_tree, x->parent, thread_id);
                x = binary_tree->root;
            }
        }
    }
    if (x != NULL) x->color = BLACK;
}

void removeNode(struct binary_tree *binary_tree, struct TreeNode *z, int thread_id) {
    struct TreeNode *y = z;
    struct TreeNode *x = NULL;
    Color y_original_color = y->color;

    if ( z->left != NULL && z->right != NULL ) {
        y = minimum(z->right);

        int exe_time_y = get_sum_exe_time_of_node(binary_tree, y, thread_id);
        struct TreeNode* cur = z->right;
        while (cur != y) {
            cur->left_subtree_sum -= exe_time_y;
            cur = cur->left;
        }

	void *remove_data = z->data;
	z->data = y->data;
	z->dup_next = y->dup_next;
	y->data = remove_data;
	y->dup_next = NULL;
        
	removeNode(binary_tree, y, thread_id);
        return;
    }

    if (z->left == NULL) {
        x = z->right;
        transplant(binary_tree, z, z->right);

    } else if (z->right == NULL) {
        x = z->left;
        transplant(binary_tree, z, z->left);

    }

    deleteNode(binary_tree, z);
    if (y_original_color == BLACK) {
        deleteFixup(binary_tree, x, thread_id);
    }
}

// Function to delete a value from a binary search tree
void delete_i(struct binary_tree *binary_tree, void *data, bool *deleted, int thread_id) {

    assert(binary_tree != NULL);
    *deleted = false;

    struct TreeNode* z = binary_tree->root;
    while (z != NULL && binary_tree->get_priority_fn(z->data) != binary_tree->get_priority_fn(data)) {
        if (binary_tree->get_priority_fn(data) < binary_tree->get_priority_fn(z->data)) {
            z->left_subtree_sum -= binary_tree->get_execution_cost_fn(data, thread_id); 
            z = z->left;
        }
        else {
            z = z->right;
        }
    }

    if (z != NULL) {
        //if there are duplicated nodes in Z,
        //we just need to remove duplicated one.
        if (z->dup_next != NULL) {
            struct TreeNode* cur = z;
            struct TreeNode* prev = NULL;
            while (cur && cur->data != data) {
                prev = cur;
                cur = cur->dup_next;
            }

	    //if the removed node is the head of the linkedlist;
            if (cur == z) {
                //copy the data from the removed node.
                struct TreeNode* newroot = z->dup_next;
                newroot->color = z->color;
                newroot->left_subtree_sum = z->left_subtree_sum;
                newroot->left = z->left;
                if (newroot->left != NULL) {
                    newroot->left->parent = newroot;
                }
                newroot->right = z->right;
                if (newroot->right != NULL) {
                    newroot->right->parent = newroot;
                }

                newroot->parent = z->parent;
                
                if (z->parent) {
                    if (z->parent->left == z) {
                        z->parent->left = newroot;
                    } else {
                        z->parent->right = newroot;
                    }
                }
		deleteNode(binary_tree, z);
		*deleted = true;
            } else { //remove the node from the link list;
                prev->dup_next = cur->dup_next;
		deleteNode(binary_tree, cur);	
		*deleted = true;
            }
        } else{
            if (z->data == data) {
                removeNode(binary_tree, z, thread_id);
		*deleted = true;
            }
        }
    } else {
        *deleted = false;
	return;	
    }
}

// Function to find a value in a binary search tree (non-recursive)
/*struct TreeNode* find(struct TreeNode* root, int val) {
    while (root != NULL) {
        if (val == root->val) {
            return root; // Return the node if value is found
        } else if (val < root->val) {
            root = root->left; // Move to left subtree if value is less
        } else {
            root = root->right; // Move to right subtree if value is greater
        }
    }
    return NULL; // Return NULL if value is not found or if the tree is empty
}*/

bool is_empty(struct binary_tree *binary_tree) {
	assert(binary_tree != NULL);

	return binary_tree->root == NULL;
}

void inorder(struct binary_tree *binary_tree, struct TreeNode* root)
{
    assert(binary_tree != NULL);

    if(root == NULL)
        return;
    inorder(binary_tree, root->left);
    printf("%lu ", binary_tree->get_priority_fn(root->data));
    inorder(binary_tree, root->right);
}
// return the sum of nodes' execution time that less than the target priority
uint64_t findMaxValueLessThan(struct binary_tree *binary_tree, struct TreeNode* root, void *target, int thread_id) {
    assert(binary_tree != NULL);
    
    if (root == NULL) {
        return 0;
    }
    if (binary_tree->get_priority_fn(target) == binary_tree->get_priority_fn(root->data)) {
        return root->left_subtree_sum;
    } else if (binary_tree->get_priority_fn(target) < binary_tree->get_priority_fn(root->data)) {
        return findMaxValueLessThan(binary_tree, root->left, target, thread_id);
    } else {
        return get_sum_exe_time_of_node(binary_tree, root, thread_id) + root->left_subtree_sum + findMaxValueLessThan(binary_tree, root->right, target, thread_id);
    }

}

struct TreeNode* makeEmpty(struct binary_tree *binary_tree, struct TreeNode* root)
{
    assert(binary_tree != NULL);
    
    if(root != NULL) {
        makeEmpty(binary_tree, root->left);
        makeEmpty(binary_tree, root->right);
        deleteNode(binary_tree, root);
    }
    return NULL;
}

