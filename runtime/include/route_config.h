#pragma once

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "dispatcher_options.h"
#include "admissions_control.h"
#include "runtime.h"
#include "scheduler_options.h"

enum route_config_member
{
	route_config_member_route,
	route_config_member_request_type,
	route_config_member_n_resas,
	route_config_member_group_id,
	route_config_member_path,
	route_config_member_admissions_percentile,
	route_config_member_expected_execution_us,
	route_config_member_relative_deadline_us,
	route_config_member_http_resp_content_type,
	route_config_member_len
};

extern int groups[route_config_member_len];

struct route_config {
	char    *route;
	uint8_t  request_type;
	uint32_t n_resas;
	uint32_t group_id;
	char    *path;
	uint8_t  admissions_percentile;
	uint32_t expected_execution_us;
	uint64_t expected_execution_cycle; /* exepected exectuion in cycle */
	uint32_t relative_deadline_us;
	char    *http_resp_content_type;
};

static inline void
route_config_deinit(struct route_config *config)
{
	/* ownership of the route and http_resp_content_type strings was moved during http_router_add_route */
	assert(config->route == NULL);
	assert(config->http_resp_content_type == NULL);

	/* ownership of the path stringswas moved during module_alloc */
	assert(config->path == NULL);
}

static inline void
route_config_print(struct route_config *config)
{
	printf("[Route] Route: %s\n", config->route);
	printf("[Route] Request type: %hhu\n", config->request_type);
	printf("[Route] Request type: %hhu\n", config->request_type);
	printf("[Route] Path: %s\n", config->path);
	printf("[Route] Admissions Percentile: %hhu\n", config->admissions_percentile);
	printf("[Route] Expected Execution (us): %u\n", config->expected_execution_us);
	printf("[Route] Relative Deadline (us): %u\n", config->relative_deadline_us);
	printf("[Route] HTTP Response Content Type: %s\n", config->http_resp_content_type);
}

/**
 * Validates a route config generated by a parser
 * @param config
 * @param did_set boolean array of size route_config_member_len indicating if parser set the associated member
 */
static inline int
route_config_validate(struct route_config *config, bool *did_set)
{
	if (did_set[route_config_member_route] == false) {
		fprintf(stderr, "path field is required\n");
		return -1;
	}

	if (did_set[route_config_member_request_type] == false) {

               fprintf(stderr, "request type field is required\n");
                return -1;
       }

	if (did_set[route_config_member_path] == false) {
		fprintf(stderr, "path field is required\n");
		return -1;
	}

	if (did_set[route_config_member_http_resp_content_type] == false) {
		fprintf(stderr, "http_resp_content_type not set, defaulting to text/plain\n");
		config->http_resp_content_type = "text/plain";
	}

	if (scheduler != SCHEDULER_FIFO) {
		if (did_set[route_config_member_relative_deadline_us] == false) {
			fprintf(stderr, "relative_deadline_us is required\n");
			return -1;
		}

		if (config->relative_deadline_us > (uint32_t)RUNTIME_RELATIVE_DEADLINE_US_MAX) {
			fprintf(stderr, "Relative-deadline-us must be between 0 and %u, was %u\n",
			        (uint32_t)RUNTIME_RELATIVE_DEADLINE_US_MAX, config->relative_deadline_us);
			return -1;
		}

#ifdef ADMISSIONS_CONTROL
		if (did_set[route_config_member_expected_execution_us] == false) {
			fprintf(stderr, "expected-execution-us is required\n");
			return -1;
		}

		if (did_set[route_config_member_admissions_percentile] == false) {
			fprintf(stderr, "admissions_percentile is required\n");
			return -1;
		}

		if (config->admissions_percentile > 99 || config->admissions_percentile < 50) {
			fprintf(stderr, "admissions-percentile must be > 50 and <= 99 but was %u\n",
			        config->admissions_percentile);
			return -1;
		}

		/* If the ratio is too big, admissions control is too coarse */
		uint32_t ratio = config->relative_deadline_us / config->expected_execution_us;
		if (ratio > ADMISSIONS_CONTROL_GRANULARITY) {
			fprintf(stderr,
			        "Ratio of Deadline to Execution time cannot exceed admissions control "
			        "granularity of "
			        "%d\n",
			        ADMISSIONS_CONTROL_GRANULARITY);
			return -1;
		}
#endif
	}
	
 	if (dispatcher == DISPATCHER_DARC) {
	    if (did_set[route_config_member_group_id] == false) {
		fprintf(stderr, "group id is required for DARC\n");
		return -1;
	    }

	    if (groups[config->group_id] == 0) {
                groups[config->group_id] = config->n_resas;
            } else {
                if (groups[config->group_id] != config->n_resas) {
                    fprintf(stderr, "same group id %d has different n-resas config, must be same\n", config->group_id);
                    return -1;
                }
            }
        }
	
	return 0;
}
