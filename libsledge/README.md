The aWsm compiler is responsible for compiling a valid WebAssembly binary into LLVM bitcode implementing the WebAssembly specification. However, this does not mean that the output LLVM bitcode actually contains all of the functionality to execute the WebAssembly environment. The compiler is responsible for generating certain aspects of the WebAssembly runtime environment (the operand stack, the function index space, the type index space, locals, globals, and many of the instructions etc.), but it only generates unresolved external symbols for other aspects (the linear memory, the indirect table, traps, and instructions that do not cleanly or safely map to LLVM intrinsic functions). Additionally, some instructions such as `call_direct` generate most of the logic, but still depend on helper functions that necessarily relate to a specific instruction.

Given that the WebAssembly specification has evolved since our first implementation, aWsm only supports a subset of WebAssembly instructions. Based on our experience compiling various sample apps, this subset seems to handle clang and wasi-libc well. See the appendix at the end of this document for a complete list of unsupported instructions.


When feasible, the compiler generates equivalent native code directly or mapped to equivalent LLVM intrinsics (functions that the LLVM toolchain can directly generate) or code generated by the compiler. The following instructions are handled in this way. Please note that the aWsm compiler has a special flag for generating "fast unsafe" code. What this means in practice is that a WebAssembly instruction is mapped to an LLVM intrinsic, but that the intrinsic might not strictly follow the specified behavior. Instructions that behave in this manner are followed by an asterisk (*). Additionally instructions that are implemented by an intrinsic are labeled as such.

Fully Implemented by aWsm compiler via codegen or intrinsics
```
# Control Instructions
# https://webassembly.github.io/spec/core/syntax/instructions.html#control-instructions
block / end
loop / end
if / else /end
br
br_if
br_table
return
unreachable (via intrinsic llvm.trap)
call
nop

# Parametric Instructions
# https://webassembly.github.io/spec/core/syntax/instructions.html#parametric-instructions
drop
select

# Variable Instructions
# https://webassembly.github.io/spec/core/syntax/instructions.html#variable-instructions
local.get
local.set
local.tee
global.get
global.set

# Numeric Instructions
i32.const
i64.const
f32.const
f64.const
i32.clz (via intrinsic llvm.ctlz.i32)
i64.clz (via intrinsic llvm.ctlz.i64)
i32.ctz (via intrinsic llvm.cttz.i32)
i64.ctz (via intrinsic llvm.cttz.i64)
i32.popcnt (via intrinsic llvm.ctpop.i32)
i64.popcnt (via intrinsic llvm.ctpop.i64)
f32.abs (via intrinsic llvm.fabs.f32)
f64.abs (via intrinsic llvm.fabs.f64)
f32.neg
f64.neg
f32.sqrt (via intrinsic llvm.sqrt.f32)
f64.sqrt (via intrinsic llvm.sqrt.f64)
i32.add
i64.add
i32.sub
i64.sub
i32.mul
i64.mul
i32.div_s *
i32.div_u *
i64.div_s *
i64.div_u *
i32.rem_s *
i32.rem_u *
i64.rem_s *
i64.rem_u *
i32.and
i64.and
i32.or
i64.or
i32.xor
i64.xor
i32.shl
i64.shl
i32.shr_u
i32.shr_s
i64.shr_u
i64.shr_s
f32.add
f64.add
f32.sub
f64.sub
f32.mul
f64.mul
f32.div
f64.div
i32.eqz
i64.eqz
i32.eq
i64.eq
i32.ne
i64.ne
i32.lt_s
i64.lt_u
i32.gt_s
i64.gt_u
i32.le_s
i64.le_u
i32.ge_s
i64.ge_u
f32.eq
f64.eq
f32.ne
f64.ne
f32.lt
f64.lt
f32.gt
f64.gt
f32.le
f64.le
f32.ge
f64.ge
i32.wrap_i64
i64.extend_i32_s
i64.extend_i32_u
i32.trunc_f32_s *
i32.trunc_f32_u *
i32.trunc_f64_s *
i32.trunc_f64_u *
f32.demote_f64
f64.promote_f32
f32.convert.i32_s
f32.convert.i32_u
f32.convert.i64_s
f32.convert.i64_u
f64.convert.i32_s
f64.convert.i32_u
f64.convert.i64_s
f64.convert.i64_u
i32.reinterpret_f32
i64.reinterpret_f64
f32.reinterpret_i32
f64.reinterpret_i64
```

The compiler resolved control instructions by internally maintains the execution call stack and runtime stack during compilation and generating equivalent LLVM basic blocks and phi instructions. It i


These WebAssembly instructions are linked to unresolved external symbols that have to be resolved by a subsequent linking step with runtime functions implementing these portions of the WebAssembly specification. This set of external symbols constitutes an ABI (henceforth called the "aWsm ABI"):

```
# Control Instructions
call_indirect -> get_function_from_table

# Numeric Instructions
i32.rotl -> rotl_u32
i64.rotl -> rotl_u64
i32.rotr -> rotr_u32
i64.rotr -> rotr_u64
f32.ceil -> f32_ceil
f64.ceil -> f64_ceil
f32.floor -> f32_floor
f64.floor -> f64_floor
f32.trunc -> f32_trunc_f32
f64.trunc -> f64_trunc_f64
f32.nearest -> f32_nearest
f64.nearest -> f64_nearest
f32.min -> f32_min
f64.min -> f64_min
f32.max -> f32_max
f64.max -> f64_max
f32.copysign -> f64_copysign
i64.trunc_f32_s -> i64_trunc_f32
i64.trunc_f32_u -> u64_trunc_f32
i64.trunc_f64_s -> i64_trunc_f64
i64.trunc_f64_u -> u64_trunc_f64

# Memory Instructions
i32.load -> get_i32
i64.load -> get_i64
f32.load -> get_f32
f64.load -> get_f64
i32.store -> set_i32
i64.store -> set_i64
f32.store -> set_f32
f64.store -> set_f64
i32.load8_s -> get_i8
i32.load8_u -> get_i8
i32.load16_s -> get_i16
i32.load16_u -> get_i64
i64.load8_s -> get_i8
i64.load8_u -> get_i8
i64.load16_s -> get_i16
i64.load16_u -> get_i16
i64.load32_s -> get_i32
i64.load32_u -> get_i32
i32.store8 -> set_i8
i32.store16 -> set_i16
i64.store8 -> set_i8
i64.store16 -> set_i16
i64.store32 -> set_i32
memory.size -> instruction_memory_size
memory.grow -> instruction_memory_grow
```

When not compiled with the unsafe flag, also the following
```
# Numeric Instructions
i32.div_s -> i32_div
i32.div_u -> u32_div
i64.div_s -> i64_div
i64.div_u -> u64_div
i32.rem_s -> i32_rem
i32.rem_u -> u32_rem
i64.rem_s -> i64_rem
i64.rem_u -> u64_rem
i32.trunc_f32_s -> i32_trunc_f32
i32.trunc_f32_u -> u32_trunc_f32
i32.trunc_f64_s -> i32_trunc_f64
i32.trunc_f64_u -> u32_trunc_f64
```

In addition to the above instructions, aWsm generates "runtime stubs" that relate to how an aWsm module is initialized by an embedding runtime. This differs from the WebAssembly instantiation algorithm in the specification. 

## TODO: Add function signatures
populate_globals

populate_table
table_fetch
table_add

u32 starting_pages
u32 max_pages
initialize_region
populate_memory

All globals are exposed as symbols prefixed by wasmg_

All exported functions are exposed as symbols prefixed by wasmf_X. If not exported, they are exported with wasmf_internal_X. If the source WebAssembly module provided the optional name section, the name is preserved for non-exported functions for debugging purposes. Otherwise, the index of the function within the module's function namespace is used. Typically, an aWsm module is compiled against the WASI standard, which means that the entrypoint `_start` is exposed as `wasmf_start`

Here is the same ABI depicted as a C header:

TODO: Complete this

```c
/* Memory Instructions */

/* memory.size */
uint32_t instruction_memory_size(void);
/* memory.grow */
int32_t instruction_memory_grow(uint32_t count);
/* memory.init? memory.fill? memory.copy? data.drop? */
void initialize_region(uint32_t offset, uint32_t region_size, uint8_t region[region_size]);
/* f32.load */
float get_f32(uint32_t offset);
/* f64.load */
double get_f64(uint32_t offset);
/* i8.load */
int8_t get_i8(uint32_t offset);
/* i16.load */
int16_t get_i16(uint32_t offset);
/* i32.load */
int32_t get_i32(uint32_t offset);
/* i64.load */
int64_t get_i64(uint32_t offset);
/* Unclear */
int32_t get_global_i32(uint32_t offset);
int64_t get_global_i64(uint32_t offset);
/* f32.store */
void set_f32(uint32_t offset, float value)
/* f64.store */
void set_f64(uint32_t offset, double value);
/* i8.store */
void set_i8(uint32_t offset, int8_t value);
/* i16.store */
void set_i16(uint32_t offset, int16_t value);
/* i32.store */
void set_i32(uint32_t offset, int32_t value);
/* i64.store */
void set_i64(uint32_t offset, int64_t value);
/* Unclear */
void set_global_i32(uint32_t offset, int32_t value);
void set_global_i64(uint32_t offset, int64_t value);

/* Numeric Instructions */

/* i32.rotl */
uint32_t rotl_u32(uint32_t n, uint32_t c_u32);
/* i32.rotr */
uint32_t rotr_u32(uint32_t n, uint32_t c_u32);
/* i64.rotl */
uint64_t rotl_u64(uint64_t n, uint64_t c_u64)
/* i64.rotr */
uint64_t rotr_u64(uint64_t n, uint64_t c_u64);
/* i32.div_u if not compiled with use_fast_unsafe option */
uint32_t u32_div(uint32_t a, uint32_t b);
/* i32.rem_u if not compiled with use_fast_unsafe option */
uint32_t u32_rem(uint32_t a, uint32_t b);
/* i32.div_s if not compiled with use_fast_unsafe option */
int32_t i32_div(int32_t a, int32_t b);
/* i32.rem_s if not compiled with use_fast_unsafe option */
int32_t i32_rem(int32_t a, int32_t b);
/* i64.div_u if not compiled with use_fast_unsafe option */
uint64_t u64_div(uint64_t a, uint64_t b);
/* i64.rem_u if not compiled with use_fast_unsafe option */
uint64_t u64_rem(uint64_t a, uint64_t b);
/* i64.div_s if not compiled with use_fast_unsafe option */
int64_t i64_div(int64_t a, int64_t b);
/* i64.rem_s if not compiled with use_fast_unsafe option */
int64_t i64_rem(int64_t a, int64_t b);
/* i32.trunc_f32_u if not compiled with use_fast_unsafe option */
uint32_t u32_trunc_f32(float f);
/* i32.trunc_f32_s if not compiled with use_fast_unsafe option */
int32_t i32_trunc_f32(float f);
/* i32.trunc_f32_u if not compiled with use_fast_unsafe option */
uint32_t u32_trunc_f64(double f);
/* i32.trunc_f64_s if not compiled with use_fast_unsafe option */
int32_t i32_trunc_f64(double f);
/* i32.trunc_f64_u if not compiled with use_fast_unsafe option */
uint64_t u64_trunc_f32(float f);
int64_t i64_trunc_f32(float f);
uint64_t u64_trunc_f64(double f);
int64_t i64_trunc_f64(double f);
float f32_trunc_f32(float f);
/* f32.min */
float f32_min(float a, float b);
/* f32.max */
float f32_max(float a, float b);
/* f32.floor */
float f32_floor(float a);
/* f64.min */
double f64_min(double a, double b);
/* f64.max */
double f64_max(double a, double b);
/* f64.floor */
double f64_floor(double a);

/* Table Instructions */

void add_function_to_table(uint32_t idx, uint32_t type_id, char *pointer);
char *get_function_from_table(uint32_t idx, uint32_t type_id);
```

The libsledge library is a static archive that is linked with the LLVM bitcode output by the aWsm compiler to yield a SLEdge module. Technically, this library is a form of optimization. Under a simpler design, aWsm generated LLVM bitcode could be directly compiled to a dynamic shared library (*.so) capable of being loaded by the SLEdge runtime. 




By doing this, the external unresolved symbols generated by the aWsm 



As such, libsledge effectively wraps the ABI of external symbols generated by aWsm , yielding a different ABI called the "SLEdge ABI." 



the SLEdge runtime 


sledgert 



The reason for this difference is that some of the backing functions implementing the wasm32 specification are amenable to aggressively inlining and optimization. In particular, the wasm32 implementation of memory and function tables are inlined in order to allow the execution of a SLEdge module to more closely match that of native memory accesses and function pointers. 


e this code


A WebAssembly module instance is statically linked with the backing functions implementing , yielding a *.so file that SLEdge can execute. This ensures that the instance is able to .

They are broken into instruction types as on https://webassembly.github.io/spec/core/exec/instructions.html. They depend on common headers for the WebAssembly types located in the WebAssembly instance struct. These are located in runtime/include/common.


# Appendix: Unsupported Instructions

This is based on the WebAssembly specification at https://webassembly.github.io/spec/core/index.html as of 12/23/2021.
## TODO: Add suggested flags to avoid emitting these instructions with various compilers

Currently the aWsm compiler **does not** support any of the following instructions:
```
# Numeric Instructions
i32.extend8_s
i64.extend8_s
i32.extend16_s
i64.extend16_s
i64.extend32_s
i32.trunc_sat_f32_s
i32.trunc_sat_f32_u
i32.trunc_sat_f64_s
i32.trunc_sat_f64_u
i64.trunc_sat_f32_s
i64.trunc_sat_f32_u
i64.trunc_sat_f64_s
i64.trunc_sat_f64_u

# Reference instructions
ref.null
ref.is_null
ref.func

# Table instructions
table.get
table.set
table.size
table.grow
table.fill
table.copy
table.init
elem.drop

# Memory Instructions
v128.load
v128.store
v128.load8x8_s
v128.load8x8_u
v128.load16x4_s
v128.load16x4_u
v128.load32x2_s
v128.load32x2_u
v128.load32_zero
v128.load64_zero
v128.load8_splat
v128.load16_splat
v128.load32_splat
v128.load64_splat
v128.load8_lane
v128.load16_lane
v128.load32_lane
v128.load64_lane
v128.store8_lane
v128.store16_lane
v128.store32_lane
v128.store64_lane
memory.fill
memory.copy
memory.init
data.drop


# Vector Instructions
v128.const
v128.not
v128.and
v128.andnot
v128.or
v128.xor
v128.bitselect
v128.any_true
v128.all_true
i8x16.shuffle
i8x16.swizzle
i8x16.splat
i16x8.splat
i32x4.splat
i64x2.splat
f32x4.splat
f64x2.splat
i8x16.extract_lane_s
i8x16.extract_lane_u
i16x8.extract_lane_s
i16x8.extract_lane_u
i32x4.extract_lane
i64x2.extract_lane
f32x4.extract_lane
f64x2.extract_lane
i8x16.replace_lane
i16x8.replace_lane
i32x4.replace_lane
i64x2.replace_lane
f32x4.replace_lane
f64x2.replace_lane
i8x16.eq
i16x8.eq
i32x4.eq
i8x16.ne
i16x8.ne
i32x4.ne
i8x16.lt_s
i16x8.lt_s
i32x4.lt_s
i8x16.lt_u
i16x8.lt_u
i32x4.lt_u
i8x16.gt_s
i16x8.gt_s
i32x4.gt_s
i8x16.gt_u
i16x8.gt_u
i32x4.gt_u
i8x16.le_s
i16x8.le_s
i32x4.le_s
i8x16.le_u
i16x8.le_u
i32x4.le_u
i8x16.ge_s
i16x8.ge_s
i32x4.ge_s
i8x16.ge_u
i16x8.ge_u
i32x4.ge_u
i64x2.eq
i64x2.ne
i64x2.lt_s
i64x2.gt_s
i64x2.le_s
i64x2.ge_s
f32x4.eq
f64x2.eq
f32x4.ne
f64x2.ne
f32x4.lt
f64x2.lt
f32x4.gt
f64x2.gt
f32x4.le
f64x2.le
f32x4.ge
f64x2.ge
i8x16.abs
i16x8.abs
i32x4.abs
i64x2.abs
i8x16.neg
i16x8.neg
i32x4.neg
i64x2.neg
i8x16.popcnt
i16x8.q15mulr_sat_s
i32x4.dot_i16x8_s
f32x4.abs
f64x2.abs
f32x4.neg
f64x2.neg
f32x4.sqrt
f64x2.sqrt
f32x4.ceil
f64x2.ceil
f32x4.floor
f64x2.floor
f32x4.trunc
f64x2.trunc
f32x4.nearest
f64x2.nearest
i8x16.all_true
i16x8.all_true
i32x4.all_true
i64x2.all_true
i8x16.bitmask
i16x8.bitmask
i32x4.bitmask
i64x2.bitmask
i8x16.min_u
i16x8.min_u
i32x4.min_u
i8x16.min_s
i16x8.min_s
i32x4.min_s
i8x16.max_u
i16x8.max_u
i32x4.max_u
i8x16.max_s
i16x8.max_s
i32x4.max_s
i8x16.add_sat_s
i16x8.add_sat_s
i8x16.add_sat_u
i16x8.add_sat_u
i8x16.sub_sat_s
i16x8.sub_sat_s
i8x16.sub_sat_u
i16x8.sub_sat_u
i16x8.mul
i32x4.mul
i64x2.mul
i8x16.avgr_u
i16x8.avgr_u
i16x8.extmul_low_i8x16_u
i16x8.extmul_low_i8x16_s
i16x8.extmul_high_i8x16_u
i16x8.extmul_high_i8x16_s
i32x4.extmul_low_i16x8._u
i32x4.extmul_low_i16x8._s
i32x4.extmul_high_i16x8._u
i32x4.extmul_high_i16x8._s
i64x2.extmul_low_i32x4._s
i64x2.extmul_low_i32x4._u
i64x2.extmul_high_i32x4._s
i64x2.extmul_high_i32x4._u
i16x8.extadd_pairwise_i8x16_s
i16x8.extadd_pairwise_i8x16_u
i32x4.extadd_pairwise_i16x8_s
i32x4.extadd_pairwise_i16x8_u
f32x4.add
f64x2.add
f32x4.sub
f64x2.sub
f32x4.mul
f64x2.mul
f32x4.div
f64x2.div
f32x4.min
f64x2.min
f32x4.max
f64x2.max
f32x4.pmin
f64x2.pmin
f32x4.pmax
f64x2.pmax
i32x4.trunc_sat_f32x4_s
i32x4.trunc_sat_f32x4_u
i32x4.trunc_sat_f64x2_s_zero
i32x4.trunc_sat_f64x2_u_zero
f32x4.convert_i32x4.s
f32x4.convert_i32x4.u
f32x4.demote_f64x2_zero
f64x2.convert_low_i32x4_s
f64x2.convert_low_i32x4_u
f64x2.promote_low_f32x4
```
